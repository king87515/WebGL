<html>

<head>
<title>鏡子與霧，但不含鏡子不含霧 - IGL WebGL course 11</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="../GLjs/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="../GLjs/webgl-utils.js"></script>

<script id="shader-header" type="x-shader/x-header">
  #define MAX_LIGHT 1
  #define M_PI 3.1415926535897932384626433832795
  precision mediump float;
  struct glLight {//don't use gl_light
    vec4 position;
    vec4 direction;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    float spotCutOff;
    float constantAttenuation;
    float linearAttenuation;
    float quadraticAttenuation;
    float spotExponent;
    bool enable;
  };
  struct glMaterial {//don't use gl_Material
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    vec4 emission;
    float shiness;
  };
  bool isZero(float number){
    return abs(number) <= 1e-3;
  }
</script>

<script id="shader-fs" type="x-shader/x-fragment">
  varying vec2 vTextureCoord;
  varying vec3 vNormal;
  varying vec3 vLight;
  varying vec3 vEye;

  uniform bool uUseLighting;

  uniform mat4 uModelMatrix;
  uniform mat4 uViewMatrix;
  uniform mat3 uNormalMatrix;

  uniform glMaterial uFrontMaterial;

  //不特別實作背面
  //uniform glMaterial uBackMaterial;

  uniform glLight uLights[MAX_LIGHT];

  uniform sampler2D uSampler;
  vec4 calculateLight(
      glLight lightData, glMaterial material_data,
      vec3 Normal, vec3 Light, vec3 LightDir, float LightDist, vec3 Eye, vec3 Half, vec4 texel
  ){
    float I_D = max(dot(Normal,Light),0.0);
    float I_S = pow(max(dot(Half,Normal),0.0),material_data.shiness);

    vec4 diffuse = I_D * lightData.diffuse * material_data.diffuse * texel;
    vec4 specular = vec4(I_S * lightData.specular.rgb * material_data.specular.rgb, 1.0);
    vec4 ambient = lightData.ambient * material_data.ambient * texel;
    float attenuation = 1.0;

    if (lightData.spotCutOff <= M_PI - 1e-3 && lightData.spotCutOff >= -1e-3) { // the light is a spotlight
        float spotCosine = dot(LightDir, -Light.xyz);
        if (spotCosine >= cos(lightData.spotCutOff)) {
            attenuation = clamp(pow(spotCosine,lightData.spotExponent), 0.0, 1.0);
        }else{
          attenuation = 0.0;
        }
    }

    attenuation = attenuation / (lightData.constantAttenuation
        + lightData.linearAttenuation * LightDist
        + lightData.quadraticAttenuation * LightDist * LightDist);

    return ambient + ( diffuse + specular )
     * attenuation
    ;
  }
  void main(void) {
    vec4 texel = texture2D(uSampler, vTextureCoord.st );
    if (!uUseLighting) {
      gl_FragColor = texel;
    }else{
      vec3 illumination = vec3(0.0, 0.0, 0.0);
      for(int i = 0; i < MAX_LIGHT; ++i){
          if(!uLights[i].enable) continue;
          vec4 eyeLightPos = uViewMatrix * uLights[i].position;
          vec3 Normal = normalize(vNormal);

          vec3 Light = eyeLightPos.xyz + vEye.xyz;
          float LightDist = length(Light);
          Light = normalize(Light);
          vec3 LightDir = Light;
          if( !isZero(length(uLights[i].direction.xyz)) ) LightDir = normalize(-(uViewMatrix * uLights[i].direction).xyz);
          if( isZero(uLights[i].position.w) ) Light = LightDir; // is directional light

          vec3 Eye = normalize(vEye);
          vec3 Half = normalize(Eye+Light);

          illumination +=
              clamp(
                    calculateLight(uLights[i], uFrontMaterial, Normal, Light, LightDir, LightDist, Eye, Half, texel).rgb
              , 0.0, 1.0)
              ;
      }


      gl_FragColor = vec4(clamp(illumination, 0.0, 1.0), texel.a);
    }
  }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  attribute vec3 aVertexNormal;
  attribute vec2 aTextureCoord;

  uniform mat4 uViewMatrix;
  uniform mat4 uModelMatrix;
  uniform mat4 uProjectionMatrix;
  uniform mat3 uNormalMatrix;

  uniform glLight uLights[MAX_LIGHT];

  uniform bool uUseLighting;
  varying vec2 vTextureCoord;

  //法向量線性內插
  varying vec3 vNormal;

  //眼睛相對點的向量線性內插
  varying vec3 vEye;

  void main(void) {
    //local variable; ModelViewMatrix; Model Matrix和View Matrix之積 (後乘法)
    mat4 lModelViewMatrix = uViewMatrix * uModelMatrix;
    gl_Position = uProjectionMatrix * lModelViewMatrix * vec4(aVertexPosition, 1.0);
    vTextureCoord = aTextureCoord;

    vec4 eyePosition = lModelViewMatrix * vec4(aVertexPosition, 1.0);
    vNormal =  normalize(uNormalMatrix * aVertexNormal);
    vEye = -eyePosition.xyz;

  }
</script>

<script type="text/javascript">

    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
        //若不提供uniform boolean傳遞，則用uniform1i代替
        if(typeof gl.uniform1b !== 'function')
        gl.uniform1b = function(binding_data, bool_val){
          gl.uniform1i(binding_data, !bool_val ? 0 : 1);
        };
    }

    var lightStructMembers = [
      "position",
      "direction",

      "diffuse",
      "specular",
      "ambient",

      "spotCutOff",
      "constantAttenuation",
      "linearAttenuation",
      "quadraticAttenuation",
      "spotExponent",
      "enable"
    ];

    var materialStructMembers = [
      "ambient",
      "diffuse",
      "specular",
      "emission",
      "shiness"
    ];
    var light_sources = [];
    var numLights = 1;

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        var shaderHeader = document.getElementById("shader-header");
        if (!shaderScript) {
            return null;
        }

        var str = "", header = '';
        var k = shaderScript.firstChild;
        while (k) {
          if (k.nodeType == 3) str += k.textContent;
          k = k.nextSibling;
        }

        k = shaderHeader.firstChild;
        while (k) {
          if (k.nodeType == 3) header += k.textContent;
          k = k.nextSibling;
        }
        if(header && header !== '')str = header + '\n' + str;

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

        shaderProgram.projectionMatrixUniform =
        gl.getUniformLocation(shaderProgram, "uProjectionMatrix");
        shaderProgram.viewMatrixUniform =
        gl.getUniformLocation(shaderProgram, "uViewMatrix");
        shaderProgram.modelMatrixUniform =
        gl.getUniformLocation(shaderProgram, "uModelMatrix");
        shaderProgram.normalMatrixUniform =
        gl.getUniformLocation(shaderProgram, "uNormalMatrix");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
        shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram, "uUseLighting");
        shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientColor");
        shaderProgram.pointLightingLocationUniform = gl.getUniformLocation(shaderProgram, "uPointLightingLocation");
        shaderProgram.pointLightingColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingColor");

        shaderProgram.FrontMaterialUniform = {};
        var structMembers = {};
        //將結構中每個成員變數Bind，並且儲存Bind資訊
        for (var jj = 0; jj < materialStructMembers.length; ++jj) {
          var name = materialStructMembers[jj];
          structMembers[name] = gl.getUniformLocation(shaderProgram,
            //組合出GLSL的Syntax以便Binding
            "uFrontMaterial." + name);
        }
        shaderProgram.FrontMaterialUniform = structMembers;

        shaderProgram.lightsUniform = {};
        //場景中可以有多盞燈
        for (var ll = 0; ll < numLights; ++ll) {
          structMembers = {};
          //將結構中每個成員變數Bind，並且儲存Bind資訊
          for (var jj = 0; jj < lightStructMembers.length; ++jj) {
            var name = lightStructMembers[jj];
            structMembers[name] = gl.getUniformLocation(shaderProgram,
              //組合出GLSL的Syntax以便Binding
              "uLights[" + ll + "]." + name);
            }
            shaderProgram.lightsUniform[ll] = structMembers;
          }
    }


    function handleLoadedTexture(texture) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);

        gl.bindTexture(gl.TEXTURE_2D, null);
    }


    var moonTexture;
    var crateTexture;

    function initTextures() {
        moonTexture = gl.createTexture();
        moonTexture.image = new Image();
        moonTexture.image.onload = function () {
            handleLoadedTexture(moonTexture)
        }
        moonTexture.image.src = "moon.gif";

        crateTexture = gl.createTexture();
        crateTexture.image = new Image();
        crateTexture.image.onload = function () {
            handleLoadedTexture(crateTexture)
        }
        crateTexture.image.src = "crate.gif";
    }


    function initLighting(){
      for(var i=0; i<numLights; ++i){
        light_sources[i] = {
          direction: [0.0, 0.0, 1.0, 0.0],
          position: [0.0, 0.0, 0.0, 1.0],

          ambient: [0.3, 0.3, 0.3, 1.0],
          diffuse: [0.0, 0.0, 0.0, 1.0],
          specular: [0.8, 0.8, 0.8, 1.0],//defult no specular

          spotCutOff:  degToRad(10.0),
          spotExponent: 100.0,
          constantAttenuation: 1.0,
          linearAttenuation: 0.0,
          quadraticAttenuation: 0.0,
          enable: i == 0
        };
      }
    }
    function UpdateLighting(){
      for(var i=0; i<numLights; ++i){
        gl.uniform4fv(shaderProgram.lightsUniform[i].direction,
          light_sources[i].direction);
        gl.uniform4fv(shaderProgram.lightsUniform[i].position,
          light_sources[i].position);

        gl.uniform4fv(shaderProgram.lightsUniform[i].ambient,
          light_sources[i].ambient);
        gl.uniform4fv(shaderProgram.lightsUniform[i].diffuse,
          light_sources[i].diffuse);
        gl.uniform4fv(shaderProgram.lightsUniform[i].specular,
          light_sources[i].specular);

        gl.uniform1f(shaderProgram.lightsUniform[i].spotCutOff,
          light_sources[i].spotCutOff);
        gl.uniform1f(shaderProgram.lightsUniform[i].spotExponent,
          light_sources[i].spotExponent);

        gl.uniform1f(shaderProgram.lightsUniform[i].constantAttenuation,
          light_sources[i].constantAttenuation);
        gl.uniform1f(shaderProgram.lightsUniform[i].linearAttenuation,
          light_sources[i].linearAttenuation);
        gl.uniform1f(shaderProgram.lightsUniform[i].quadraticAttenuation,
          light_sources[i].quadraticAttenuation);

        gl.uniform1b(shaderProgram.lightsUniform[i].enable,
          light_sources[i].enable);
      }
    }

    var front_material;
    function initMaterial(){
      front_material = {
        ambient:[1.0, 1.0, 1.0, 1.0],//描述物體對環境光的反射程度
        diffuse:[1.0, 1.0, 1.0, 1.0],//描述物體的曼反射
        specular:[0.3, 0.3, 0.3, 1.0],//描述物體的鏡面反射
        emission:[0.0, 0.0, 0.0, 1.0],//描述物體的自發光
        shiness:255
      };
    }
    function UpdateMaterial(objMaterial){
      gl.uniform4fv(shaderProgram.FrontMaterialUniform.ambient,
        objMaterial.ambient);
      gl.uniform4fv(shaderProgram.FrontMaterialUniform.diffuse,
        objMaterial.diffuse);
      gl.uniform4fv(shaderProgram.FrontMaterialUniform.specular,
        objMaterial.specular);
      gl.uniform4fv(shaderProgram.FrontMaterialUniform.emission,
        objMaterial.emission);
      gl.uniform1f(shaderProgram.FrontMaterialUniform.shiness,
        objMaterial.shiness);
    }
    var TopMatrix;
    var matrix_modes = ["view", "model", "projection", "texture", "color"];
    //定義特殊矩陣
    var special_matrix_modes = {
      "modelview":{
        "get_matrix":function(){
          var result = mat4.create();
          mat4.multiply(TopMatrix("view"), TopMatrix("model"), result);
          return result;
        }
      },
      "modelviewprojection":{
        "get_matrix":function(){
          var result = mat4.create();
          mat4.multiply(TopMatrix("projection"), TopMatrix("modelview"), result);
          return result;
        }
      },
      "normal":{
        "get_matrix":function(){
          var normalMatrix = mat3.create();
          mat4.toInverseMat3(TopMatrix("modelview"), normalMatrix);
          mat3.transpose(normalMatrix);
          return normalMatrix;
        }
      },
      "identity":{
        "get_matrix":function(){
          var result = mat4.create();
          mat4.identity(result);
          return result;
        }
      }
    };
    var Matries = [];

    function initMatrix(){
      //依序初始化所有矩陣堆疊
      for(var i=0; i<matrix_modes.length; ++i){
        Matries[matrix_modes[i]] = [mat4.create()];
      }
    }
    TopMatrix = function(matrix_mode) {
      if(special_matrix_modes[matrix_mode] &&
        typeof special_matrix_modes[matrix_mode].get_matrix === "function"){
          return special_matrix_modes[matrix_mode].get_matrix();
      }
        //只作用在矩陣堆疊的頂層
      return Matries[matrix_mode][Matries[matrix_mode].length-1];
    }
    function PushMatrix(matrix_mode) {
      //建立一個零矩陣來準備儲存矩陣
      var copy = mat4.create();
      //將堆疊頂層的矩陣複製一份
      mat4.set(TopMatrix(matrix_mode), copy);
      //再放進堆疊
      Matries[matrix_mode].push(copy);
    }

    function PopMatrix(matrix_mode) {
      if (Matries[matrix_mode].length == 0) {
        throw "Invalid popMatrix!";
      }
      Matries[matrix_mode].pop();
    }

    function setMatrixUniforms() {
      gl.uniformMatrix4fv(shaderProgram.projectionMatrixUniform, false, TopMatrix("projection"));
      gl.uniformMatrix4fv(shaderProgram.viewMatrixUniform, false, TopMatrix("view"));
      gl.uniformMatrix4fv(shaderProgram.modelMatrixUniform, false, TopMatrix("model"));
      gl.uniformMatrix3fv(shaderProgram.normalMatrixUniform, false, TopMatrix("normal"));
      //尚未用到的矩陣
      //gl.uniformMatrix4fv(shaderProgram.colorMatrixUniform, false, TopMatrix("color"));
      //gl.uniformMatrix4fv(shaderProgram.textureMatrixUniform, false, TopMatrix("texture"));
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    var viewHead = 0;
    var viewRoll = 0;
    var viewEpitch = 0;
    var viewUppos = 0;
    var viewRight = 0;
    var viewZoom = 0;

    var currentlyPressedKeys = {};

    function handleKeyDown(event) {
      currentlyPressedKeys[event.keyCode] = true;
    }

    function handleKeyUp(event) {
      currentlyPressedKeys[event.keyCode] = false;
    }

    function handleKeys() {
      if (currentlyPressedKeys[83]) viewZoom += 0.05; //w
      if (currentlyPressedKeys[87]) viewZoom -= 0.05; //s
      if (currentlyPressedKeys[65]) viewRight += 0.05; //a
      if (currentlyPressedKeys[68]) viewRight -= 0.05; //d
      if (currentlyPressedKeys[90]) viewUppos += 0.05; //z
      if (currentlyPressedKeys[88]) viewUppos -= 0.05; //x

      if (currentlyPressedKeys[82]) viewEpitch += 0.5; //r
      if (currentlyPressedKeys[70]) viewEpitch -= 0.5; //f
      if (currentlyPressedKeys[84]) viewHead += 0.5; //t
      if (currentlyPressedKeys[71]) viewHead -= 0.5; //g
      if (currentlyPressedKeys[89]) viewRoll += 0.5; //y
      if (currentlyPressedKeys[72]) viewRoll -= 0.5; //h

      if (currentlyPressedKeys[81]){ //Q, 攝影機復位
        viewHead = 0;
        viewRoll = 0;
        viewEpitch = 0;
        viewUppos = 0;
        viewRight = 0;
        viewZoom = 0;
      }
      if (currentlyPressedKeys[33]) {
        // Page Up
        z -= 0.05;
      }
      if (currentlyPressedKeys[34]) {
        // Page Down
        z += 0.05;
      }
      if (currentlyPressedKeys[37]) {
        // Left cursor key
        ySpeed -= 1;
      }
      if (currentlyPressedKeys[39]) {
        // Right cursor key
        ySpeed += 1;
      }
      if (currentlyPressedKeys[38]) {
        // Up cursor key
        xSpeed -= 1;
      }
      if (currentlyPressedKeys[40]) {
        // Down cursor key
        xSpeed += 1;
      }
    }

    var cubeVertexPositionBuffer;
    var cubeVertexNormalBuffer;
    var cubeVertexTextureCoordBuffer;
    var cubeVertexIndexBuffer;

    var moonVertexPositionBuffer;
    var moonVertexNormalBuffer;
    var moonVertexTextureCoordBuffer;
    var moonVertexIndexBuffer;

    var mirrorVertexPositionBuffer;
    var mirrorVertexNormalBuffer;
    var mirrorVertexIndexBuffer;

    function initBuffers() {
        cubeVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        cubeVertexPositionBuffer.itemSize = 3;
        cubeVertexPositionBuffer.numItems = 24;

        cubeVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
        var vertexNormals = [
            // Front face
             0.0,  0.0,  1.0,
             0.0,  0.0,  1.0,
             0.0,  0.0,  1.0,
             0.0,  0.0,  1.0,

            // Back face
             0.0,  0.0, -1.0,
             0.0,  0.0, -1.0,
             0.0,  0.0, -1.0,
             0.0,  0.0, -1.0,

            // Top face
             0.0,  1.0,  0.0,
             0.0,  1.0,  0.0,
             0.0,  1.0,  0.0,
             0.0,  1.0,  0.0,

            // Bottom face
             0.0, -1.0,  0.0,
             0.0, -1.0,  0.0,
             0.0, -1.0,  0.0,
             0.0, -1.0,  0.0,

            // Right face
             1.0,  0.0,  0.0,
             1.0,  0.0,  0.0,
             1.0,  0.0,  0.0,
             1.0,  0.0,  0.0,

            // Left face
            -1.0,  0.0,  0.0,
            -1.0,  0.0,  0.0,
            -1.0,  0.0,  0.0,
            -1.0,  0.0,  0.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);
        cubeVertexNormalBuffer.itemSize = 3;
        cubeVertexNormalBuffer.numItems = 24;

        cubeVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        var textureCoords = [
            // Front face
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,

            // Back face
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            0.0, 0.0,

            // Top face
            0.0, 1.0,
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,

            // Bottom face
            1.0, 1.0,
            0.0, 1.0,
            0.0, 0.0,
            1.0, 0.0,

            // Right face
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            0.0, 0.0,

            // Left face
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        cubeVertexTextureCoordBuffer.itemSize = 2;
        cubeVertexTextureCoordBuffer.numItems = 24;

        cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
        cubeVertexIndexBuffer.itemSize = 1;
        cubeVertexIndexBuffer.numItems = 36;


        var latitudeBands = 30;
        var longitudeBands = 30;
        var radius = 2;

        var vertexPositionData = [];
        var normalData = [];
        var textureCoordData = [];
        for (var latNumber=0; latNumber <= latitudeBands; latNumber++) {
            var theta = latNumber * Math.PI / latitudeBands;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            for (var longNumber=0; longNumber <= longitudeBands; longNumber++) {
                var phi = longNumber * 2 * Math.PI / longitudeBands;
                var sinPhi = Math.sin(phi);
                var cosPhi = Math.cos(phi);

                var x = cosPhi * sinTheta;
                var y = cosTheta;
                var z = sinPhi * sinTheta;
                var u = 1 - (longNumber / longitudeBands);
                var v = 1 - (latNumber / latitudeBands);

                normalData.push(x);
                normalData.push(y);
                normalData.push(z);
                textureCoordData.push(u);
                textureCoordData.push(v);
                vertexPositionData.push(radius * x);
                vertexPositionData.push(radius * y);
                vertexPositionData.push(radius * z);
            }
        }

        var indexData = [];
        for (var latNumber=0; latNumber < latitudeBands; latNumber++) {
            for (var longNumber=0; longNumber < longitudeBands; longNumber++) {
                var first = (latNumber * (longitudeBands + 1)) + longNumber;
                var second = first + longitudeBands + 1;
                indexData.push(first);
                indexData.push(second);
                indexData.push(first + 1);

                indexData.push(second);
                indexData.push(second + 1);
                indexData.push(first + 1);
            }
        }

        moonVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);
        moonVertexNormalBuffer.itemSize = 3;
        moonVertexNormalBuffer.numItems = normalData.length / 3;

        moonVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
        moonVertexTextureCoordBuffer.itemSize = 2;
        moonVertexTextureCoordBuffer.numItems = textureCoordData.length / 2;

        moonVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
        moonVertexPositionBuffer.itemSize = 3;
        moonVertexPositionBuffer.numItems = vertexPositionData.length / 3;

        moonVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, moonVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STREAM_DRAW);
        moonVertexIndexBuffer.itemSize = 1;
        moonVertexIndexBuffer.numItems = indexData.length;

		mirrorVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, mirrorVertexPositionBuffer);
        vertices = [
            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        mirrorVertexPositionBuffer.itemSize = 3;
        mirrorVertexPositionBuffer.numItems = 24;

        mirrorVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, mirrorVertexNormalBuffer);
        var vertexNormals = [

            // Back face
             0.0,  0.0, -1.0,
             0.0,  0.0, -1.0,
             0.0,  0.0, -1.0,
             0.0,  0.0, -1.0,

        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);
        mirrorVertexNormalBuffer.itemSize = 3;
        mirrorVertexNormalBuffer.numItems = 24;

        mirrorVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mirrorVertexIndexBuffer);
        var mirrorVertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(mirrorVertexIndices), gl.STATIC_DRAW);
        mirrorVertexIndexBuffer.itemSize = 1;
        mirrorVertexIndexBuffer.numItems = 6;

        initMatrix();
    }


    var moonAngle = 180;
    var cubeAngle = 0;

	function reshape(width, height){
		    gl.viewportWidth = width;
        gl.viewportHeight = height;
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        mat4.identity(TopMatrix("projection"));
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 500.0, TopMatrix("projection"));
        //Define the current eye position and the eye-coordinate system
        mat4.identity(TopMatrix("view"));

        //Define Viewing Matrix
        mat4.lookAt([0.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0], TopMatrix("view"));
	}

  function updateLightdata(light_id){
    var light_type = document.getElementById('Light' + light_id + 'Type').selectedIndex;
    light_sources[light_id].enable = document.getElementById('Light' + light_id + 'On').checked;
    if(light_type == 3){
      var LightCutoff = parseFloat(document.getElementById("Light" + light_id + "Cutoff").value) / 46.022471910112359550561797752809 + 1;
      document.getElementById("Light" + light_id + "CutoffDisplay").innerHTML
        = ('' + (Math.floor(LightCutoff * 100.0)/100.0));
      light_sources[light_id].spotCutOff = degToRad(LightCutoff);

      var LightSpotExponent = parseFloat(document.getElementById("Light" + light_id + "SpotExponent").value) / 64.0 - 1.0;
      document.getElementById("Light" + light_id + "SpotExponentDisplay").innerHTML
        = ('' + (Math.floor(LightSpotExponent * 100.0)/100.0));
      light_sources[light_id].spotExponent = LightSpotExponent;
    }else{
      light_sources[light_id].spotCutOff = degToRad(180.0);
      light_sources[light_id].spotExponent = 1.0;
    }
    //is Directional light or Spot light
    var flag = (light_type == 1 || light_type == 3) ? ((light_type == 1) ? -1.0 : 1.0) : 0.0;
    light_sources[light_id].direction = [
      parseFloat(document.getElementById("Light" + light_id + "DirectionX").value) * flag,
      parseFloat(document.getElementById("Light" + light_id + "DirectionY").value) * flag,
      parseFloat(document.getElementById("Light" + light_id + "DirectionZ").value) * flag,
      0.0
    ];
    //is Point light or Spot light
    flag = (light_type == 2 || light_type == 3) ? 1.0 : 0.0;
    light_sources[light_id].position = [
      parseFloat(document.getElementById("Light" + light_id + "PositionX").value) * flag,
      parseFloat(document.getElementById("Light" + light_id + "PositionY").value) * flag,
      parseFloat(document.getElementById("Light" + light_id + "PositionZ").value) * flag,
      1.0 * flag
    ];
    //is Directional light or Point light or Spot light
    flag = (light_type >= 1) ? 1.0 : 0.0;
    light_sources[light_id].ambient = [
      parseFloat(document.getElementById("Light" + light_id + "AmbientR").value),
      parseFloat(document.getElementById("Light" + light_id + "AmbientG").value),
      parseFloat(document.getElementById("Light" + light_id + "AmbientB").value),
      1.0
    ];
    light_sources[light_id].diffuse = [
      parseFloat(document.getElementById("Light" + light_id + "DiffuseR").value) * flag,
      parseFloat(document.getElementById("Light" + light_id + "DiffuseG").value) * flag,
      parseFloat(document.getElementById("Light" + light_id + "DiffuseB").value) * flag,
      1.0
    ];
    light_sources[light_id].specular = [
      parseFloat(document.getElementById("Light" + light_id + "SpecularR").value) * flag,
      parseFloat(document.getElementById("Light" + light_id + "SpecularG").value) * flag,
      parseFloat(document.getElementById("Light" + light_id + "SpecularB").value) * flag,
      1.0
    ];


  }

	function drawScene() {

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    var lighting = document.getElementById("lighting").checked;
    gl.uniform1i(shaderProgram.useLightingUniform, lighting);
    if (lighting) {
      for(var i=0; i<1; ++i) updateLightdata(i);
        UpdateLighting();
    }

    PushMatrix("view");
      //Camera control
      mat4.rotate(TopMatrix("view"), degToRad(viewHead), [0.0, 1.0, 0.0]);
      mat4.rotate(TopMatrix("view"), degToRad(viewRoll), [0.0, 0.0, 1.0]);
      mat4.rotate(TopMatrix("view"), degToRad(viewEpitch), [1.0, 0.0, 0.0]);
      mat4.translate(TopMatrix("view"), [0.0, viewUppos, 0.0]);
      mat4.translate(TopMatrix("view"), [-viewRight, 0.0, 0.0]);
      mat4.translate(TopMatrix("view"), [0.0, 0.0, -viewZoom]);

      // Draw the Scene
      mat4.identity(TopMatrix("model"));

      mat4.translate(TopMatrix("model"), [0, 0, -20]);

      PushMatrix("model");
        mat4.rotate(TopMatrix("model"), degToRad(moonAngle), [0, 1, 0]);
        mat4.translate(TopMatrix("model"), [5, 0, 0]);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, moonTexture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, moonVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, moonVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexNormalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, moonVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, moonVertexIndexBuffer);
        setMatrixUniforms();
        front_material = {
          ambient:[1.0, 1.0, 1.0, 1.0],//描述物體對環境光的反射程度
          diffuse:[1.0, 1.0, 1.0, 1.0],//描述物體的曼反射
          specular:[0.05, 0.05, 0.05, 1.0],//描述物體的鏡面反射
          emission:[0.0, 0.0, 0.0, 1.0],//描述物體的自發光
          shiness:511
        };
        UpdateMaterial(front_material);
        gl.drawElements(gl.TRIANGLES, moonVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
      PopMatrix("model");

      PushMatrix("model");
        mat4.rotate(TopMatrix("model"), degToRad(cubeAngle), [0, 1, 0]);
        mat4.translate(TopMatrix("model"), [5, 0, 0]);
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, crateTexture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);

        front_material = {
          ambient:[1.0, 1.0, 1.0, 1.0],//描述物體對環境光的反射程度
          diffuse:[1.0, 1.0, 1.0, 1.0],//描述物體的曼反射
          specular:[0.3, 0.3, 0.3, 1.0],//描述物體的鏡面反射
          emission:[0.0, 0.0, 0.0, 1.0],//描述物體的自發光
          shiness:255
        };
        UpdateMaterial(front_material);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
      PopMatrix("model");
    PopMatrix("view");
	}

    function display() {
        drawScene();
    }

    var lastTime = 0;

    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;

            moonAngle += 0.05 * elapsed;
            cubeAngle += 0.05 * elapsed;
        }
        lastTime = timeNow;
    }

    function tick() {
        requestAnimFrame(tick);
        handleKeys();
        display();
        animate();
    }


    function webGLStart() {
        var canvas = document.getElementById("lesson12-canvas");
        initGL(canvas);
        initShaders();
        initBuffers();
        initTextures();
        initMaterial();
        initLighting();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        reshape(canvas.width, canvas.height);
        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;

        tick();
    }
    var old_spot_exp = [64.0, 0.0, 0.0, 0.0];
    var old_light_state = [3, 2, 1, 2];
    function updateHTMLoption(light_id) {
      var light_type_opt = document.getElementById('Light' + light_id + 'Type');
      var spot_exp_opt = document.getElementById('Light' + light_id + 'SpotExponent');
      var light_opt = document.getElementById('Light' + light_id + 'Setting');
      if(document.getElementById('Light' + light_id + 'On').checked){
        light_opt.style.display = null;
      }else{
        light_opt.style.display = 'none';
      }
      if(light_id>=1) return;
      if(old_light_state[light_id] == 3)  old_spot_exp[light_id] = spot_exp_opt.value;
      switch (light_type_opt.selectedIndex) {
        case 1:
          document.getElementById('Light' + light_id + 'Cutoff').style.display = 'none';
          document.getElementById('Light' + light_id + 'PositionRow').style.display = 'none';
          document.getElementById('Light' + light_id + 'DirectionRow').style.display = null;
          document.getElementById('Light' + light_id + 'DiffuseRow').style.display = null;
          document.getElementById('Light' + light_id + 'SpecularRow').style.display = null;
          document.getElementById('Light' + light_id + 'CutoffCellHead').style.display = 'none';
          document.getElementById('Light' + light_id + 'CutoffCellData').style.display = 'none';
          document.getElementById('Light' + light_id + 'SpotExponentDisplay').innerHTML = '0.0';
          spot_exp_opt.value = 64;
          spot_exp_opt.setAttribute('disabled', 'disabled');
          spot_exp_opt.setAttribute('pointer-events', 'none');
          break;
        case 2:
          document.getElementById('Light' + light_id + 'Cutoff').style.display = 'none';
          document.getElementById('Light' + light_id + 'PositionRow').style.display = null;
          document.getElementById('Light' + light_id + 'DirectionRow').style.display = 'none';
          document.getElementById('Light' + light_id + 'DiffuseRow').style.display = null;
          document.getElementById('Light' + light_id + 'SpecularRow').style.display = null;
          document.getElementById('Light' + light_id + 'CutoffCellHead').style.display = null;
          document.getElementById('Light' + light_id + 'CutoffCellData').style.display = null;
          document.getElementById('Light' + light_id + 'CutoffDisplay').innerHTML = '180.0';
          document.getElementById('Light' + light_id + 'SpotExponentDisplay').innerHTML = '0.0';
          spot_exp_opt.value = 64;
          spot_exp_opt.setAttribute('disabled', 'disabled');
          spot_exp_opt.setAttribute('pointer-events', 'none');
          break;
        case 3:
          document.getElementById('Light' + light_id + 'Cutoff').style.display = null;
          document.getElementById('Light' + light_id + 'PositionRow').style.display = null;
          document.getElementById('Light' + light_id + 'DirectionRow').style.display = null;
          document.getElementById('Light' + light_id + 'DiffuseRow').style.display = null;
          document.getElementById('Light' + light_id + 'SpecularRow').style.display = null;
          document.getElementById('Light' + light_id + 'CutoffCellHead').style.display = null;
          document.getElementById('Light' + light_id + 'CutoffCellData').style.display = null;
          spot_exp_opt.value = old_spot_exp[light_id];
          spot_exp_opt.removeAttribute("disabled");
          spot_exp_opt.setAttribute('pointer-events', 'auto');
          break;
        default:
          document.getElementById('Light' + light_id + 'Cutoff').style.display = 'none';
          document.getElementById('Light' + light_id + 'PositionRow').style.display = 'none';
          document.getElementById('Light' + light_id + 'DirectionRow').style.display = 'none';
          document.getElementById('Light' + light_id + 'DiffuseRow').style.display = 'none';
          document.getElementById('Light' + light_id + 'SpecularRow').style.display = 'none';
          document.getElementById('Light' + light_id + 'CutoffCellHead').style.display = 'none';
          document.getElementById('Light' + light_id + 'CutoffCellData').style.display = 'none';
          document.getElementById('Light' + light_id + 'SpotExponentDisplay').innerHTML = '0.0';
          spot_exp_opt.value = 64;
          spot_exp_opt.setAttribute('disabled', 'disabled');
          spot_exp_opt.setAttribute('pointer-events', 'none');
      }
      old_light_state[light_id] = light_type_opt.selectedIndex;
      //light_type_opt.selectedIndex
    }
</script>


</head>


<body onload="webGLStart();">
    <h2>Lessons 12 中的 Lessons 11 : 鏡子與霧，但不含鏡子不含霧</h2>

    <canvas id="lesson12-canvas" style="border: none;" width="500" height="500"></canvas>
    <br />

    <input type="checkbox" id="lighting" checked /> Use lighting<br/>
    <div style="width:100%;height:300px;overflow:auto;">
    <!-- Light 0 -->
      <h2> <input type="checkbox" id="Light0On" onclick="updateHTMLoption(0);" checked /> Light 0:</h2>
      <table style="border: 0; padding: 10px;" id="Light0Setting">
        <tr>
          <td><b>Light Type:</b></td>
          <td><b>Spot Exponent:</b> <span id="Light0SpotExponentDisplay">0.0</span> </td>
          <td id="Light0CutoffCellHead" style="display: none;"><b>Cut Off Angle:</b> <span id="Light0CutoffDisplay">180.0</span>° </td>
        </tr>
        <tr>
          <td>
            <select id="Light0Type" onchange="updateHTMLoption(0);">
              <option>Ambient</option>
              <option selected>Directional</option>
              <option>Point</option>
              <option>Spot</option>
            </select>
          </td>
          <td><input type="range" min="0" max="4096" value="64" class="slider" id="Light0SpotExponent"></td>
          <td id="Light0CutoffCellData" style="display: none;"><input type="range" min="0" max="4096" value="1335" class="slider" id="Light0Cutoff"></td>
        </tr>
          <tr id="Light0PositionRow" style="display: none;">
              <td><b>Location:</b></td>
              <td>X: <input type="text" id="Light0PositionX" value="0.0" /></td>
              <td>Y: <input type="text" id="Light0PositionY" value="0.0" /></td>
              <td>Z: <input type="text" id="Light0PositionZ" value="-20.0" /></td>
          </tr>
          <tr id="Light0DirectionRow">
              <td><b>Direction:</b></td>
              <td>X: <input type="text" id="Light0DirectionX" value="0.0" /></td>
              <td>Y: <input type="text" id="Light0DirectionY" value="1.0" /></td>
              <td>Z: <input type="text" id="Light0DirectionZ" value="0.5" /></td>
          </tr>
          <tr id="Light0DiffuseRow">
            <td><b>Diffuse:</b></td>
            <td>R: <input type="text" id="Light0DiffuseR" value="0.6" /></td>
            <td>G: <input type="text" id="Light0DiffuseG" value="0.6" /></td>
            <td>B: <input type="text" id="Light0DiffuseB" value="0.2" /></td>
          </tr>
          <tr id="Light0SpecularRow">
            <td><b>Specular:</b></td>
            <td>R: <input type="text" id="Light0SpecularR" value="0.6" /></td>
            <td>G: <input type="text" id="Light0SpecularG" value="0.6" /></td>
            <td>B: <input type="text" id="Light0SpecularB" value="0.2" /></td>
          </tr>
          <tr id="Light0AmbientRow">
            <td><b>Ambient:</b></td>
            <td>R: <input type="text" id="Light0AmbientR" value="0.3" /></td>
            <td>G: <input type="text" id="Light0AmbientG" value="0.3" /></td>
            <td>B: <input type="text" id="Light0AmbientB" value="0.1" /></td>
          </tr>
      </table>
    </div>
    <br/>
    Moon texture courtesy of <a href="http://maps.jpl.nasa.gov/">the Jet Propulsion Laboratory</a>.
    <br/>
    <p align="center"><a href="http://140.121.197.81/linss/">© 2018 IGL</a></p>
    <br/>
</body>

</html>
